<!DOCTYPE html>
<html lang="en">

<%- include('../partials/head'); %>


    <body>
        <h1>OpenCV Camera</h1>
        <div>
            <button id="actionBtn">Start</button>
        </div>
        <video id="video" width="300" height="225"></video>
        <canvas id="canvasOutput"></canvas>
        <script async src="https://docs.opencv.org/4.5.4/opencv.js" type="text/javascript"
            onload="onCvLoaded();"></script>
        <script>
            function onCvLoaded() {
                console.log('cv', cv);
                cv.onRuntimeInitialized = onReady;
            }
            const video = document.getElementById('video');
            const actionBtn = document.getElementById('actionBtn');
            const width = 300;
            const height = 225;
            const FPS = 20;
            let distanceArray = [];
            let stream;
            let streaming = false;
            let sum = 0;
            let avg = 0;
            function onReady() {
                let src;
                let dst;
                const cap = new cv.VideoCapture(video);

                actionBtn.addEventListener('click', () => {
                    if (streaming) {
                        stop();
                        actionBtn.textContent = 'Start';
                    } else {
                        start();
                        actionBtn.textContent = 'Stop';
                    }
                });

                function start() {
                    navigator.mediaDevices.getUserMedia({ video: true, audio: false })
                        .then(_stream => {
                            stream = _stream;
                            console.log('stream', stream);
                            video.srcObject = stream;
                            video.play();
                            streaming = true;
                            src = new cv.Mat(height, width, cv.CV_8UC4);
                            // gray = new cv.Mat(height, width, cv.CV_8UC1);
                            // blurred = new cv.Mat(height, width, cv.CV_8UC1);
                            // canny = new cv.Mat(height, width, cv.CV_8UC1);
                            // contours = new cv.MatVector();
                            // hierarchy = new cv.Mat(height, width, cv.CV_8UC1);
                            // dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3);

                            setTimeout(processVideo, 0)
                        })
                        .catch(err => console.log(`An error occurred: ${err}`));
                }

                function stop() {
                    if (video) {
                        video.pause();
                        video.srcObject = null;
                    }
                    if (stream) {
                        stream.getVideoTracks()[0].stop();
                    }
                    streaming = false;
                }

                function processVideo() {
                    if (!streaming) {
                        src.delete();
                        gray.delete();
                        blurred.delete();
                        canny_output.delete();
                        contours.delete();
                        hierarchy.delete();
                        dst.delete();
                        return;
                    }
                    const begin = Date.now();
                    cap.read(src)

                    let ksize = new cv.Size(3, 3);
                    var canny_output = new cv.Mat();
                    var blurred = new cv.Mat();
                    let dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3);
                    var cthresh = 500;
                    var gray = new cv.Mat();
                    var threshImage = new cv.Mat();
                    let distance = null
                    let pos = { x: 0, y: 20 };



                    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
                    cv.blur(gray, blurred, ksize);
                    cv.threshold(blurred, threshImage, 128, 255, cv.THRESH_BINARY);

                    cv.Canny(threshImage, canny_output, cthresh, cthresh * 2, 3, 0);

                    var contours = new cv.MatVector();
                    var hierarchy = new cv.Mat();
                    let poly = new cv.MatVector();
                    
                    cv.findContours(canny_output, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);

                    for (let i = 0; i < contours.size(); ++i) {
                        let tmp = new cv.Mat();
                        let cnt = contours.get(i);
                        cv.approxPolyDP(cnt, tmp, 10, true);
                        poly.push_back(tmp);
                        cnt.delete(); tmp.delete();
                        }

                    for (let i = 0; i < contours.size(); ++i) {
                        let color = new cv.Scalar(Math.round(Math.random() * 255), Math.round(Math.random() * 255), Math.round(Math.random() * 255));
                        let tmp = new cv.Mat();
                        let cnt = contours.get(i);
                       
                        
                        
                        cv.approxPolyDP(cnt, tmp, 0.02 * cv.arcLength(cnt, true), true);
                        if (tmp.rows === 4) {
                            let rect = cv.boundingRect(tmp);
                            let aspectRatio = rect.width / rect.height;
                            if ((Math.abs(aspectRatio - 1) < 0.1) && rect.width > 5) { // Keep only rectangles with aspect ratio close to 1
                                cv.drawContours(dst, poly, i, color, 1, cv.LINE_8, hierarchy, 100);

                                // Get the bounding rectangle for the contour
                                let dimensions_text = `${rect.width} x ${rect.height}`

                                // Distance calculation
                                // Just a variable to test
                                const focalLength = 2.6

                                // original square object size
                                // Just a variable to test
                                const objectSize = 9

                                pixelSize = (rect.width)

                                // desired distance to object
                                const testDistance = 100
                                const safeMargin = 20

                                // Log the dimensions of the bounding rectangle
                                distance = (objectSize * (focalLength) / (pixelSize)).toFixed(2)
                                array_distance = (objectSize * (focalLength) / (pixelSize)).toFixed(1)
                                // cv.putText(dst, dimensions_text, pos, cv.FONT_HERSHEY_SIMPLEX, 0.5, new cv.Scalar(255, 255, 255), 1);
                                // console.log(dimensions_text);
                                tempArray = distanceArray

                                if (tempArray.length = 15) {
                                    tempArray.shift()
                                    tempArray.push(parseFloat(array_distance))

                                    sum = tempArray.reduce((a, b) => a + b, 0);
                                    avg = (sum / tempArray.length)
                                    if ((array_distance - avg < 0.1) && (array_distance - avg > -0.1)) {
                                        distanceArray = tempArray
                                    }
                                }
                                
                                // console.log(distanceArray)
                                
                                

                                cv.putText(dst, `${distance} m`, pos, cv.FONT_HERSHEY_SIMPLEX, 0.5, new cv.Scalar(255, 255, 255), 1);

                                if (distance*100 > testDistance + safeMargin)
                                {
                                cv.putText(dst, `Move closer`, { x: 200, y: 20 }, cv.FONT_HERSHEY_SIMPLEX, 0.5, new cv.Scalar(255, 0, 0), 1);
                                }

                                else if (distance*100 < testDistance - safeMargin)
                                {
                                cv.putText(dst, `Move further away`, { x: 200, y: 20 }, cv.FONT_HERSHEY_SIMPLEX, 0.5, new cv.Scalar(255, 0, 0), 1);
                                }

                                else
                                {
                                cv.putText(dst, `Correct position!`, { x: 170, y: 20 }, cv.FONT_HERSHEY_SIMPLEX, 0.5, new cv.Scalar(0, 255, 0), 1);
                                }

                                // console.log(distance);

                        }
                    }
                        cnt.delete(); tmp.delete();


                       
                    }


                    cv.imshow('canvasOutput', dst);
                    const delay = 1000 / FPS - (Date.now() - begin);
                    setTimeout(processVideo, delay);
                }
            }

        </script>
    </body>

</html>